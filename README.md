# goit-algo2-hw-01

## Task 1

1. **Початковий виклик:** ```find_min_max([3, 5, 1, 9, 6, 2, 8])```.

2. Масив ділиться на ```[3, 5, 1]``` і ```[9, 6, 2, 8]```.

3. Для першої частини ```[3, 5, 1]``` рекурсивно викликається функція. Вона знову ділиться на ```[3]``` та ```[5, 1]```.

- ```[3]``` повертає ```(3, 3)```.

- ```[5, 1]``` повертає ```(1, 5)```.

- Комбінуючи ці результати, знаходимо ```min(3, 1)``` і ```max(3, 5)```, що дає ```(1, 5)```. Це мінімум і максимум для ```[3, 5, 1]```.

4. Аналогічно, для другої частини ```[9, 6, 2, 8]``` рекурсивно знаходяться мінімум і максимум.

- ```[9, 6]``` повертає ```(6, 9)```.

- ```[2, 8]``` повертає ```(2, 8)```.

- Комбінуємо: ```min(6, 2)``` і ```max(9, 8)```, що дає ```(2, 9)```.

5. Нарешті, комбінуємо результати з обох початкових частин: ```(1, 5)``` та ```(2, 9)```.

- Загальний мінімум: ```min(1, 2) = 1```.

- Загальний максимум: ```max(5, 9) = 9```.

6. Функція повертає кортеж (1, 9).

**Висновок:** Цей підхід, хоча і виглядає більш складним, ніж простий ітеративний перебір, є класичним прикладом використання парадигми **"розділяй і володарюй"** для вирішення обчислювальних задач. Його ефективність особливо помітна у паралельних обчисленнях, де різні частини масиву можуть оброблятися одночасно.

## Task 2

1. Припустимо, ми хочемо знайти 3-й найменший елемент у масиві ```[7, 2, 9, 1, 5, 8, 3]```. ```k = 3```.

2. Викликаємо ```quick_select([7, 2, 9, 1, 5, 8, 3], 3)```.

3. На першій ітерації ```partition``` обирає останній елемент ```3``` як опорний.

4. Масив розбивається на: ```[2, 1]``` (менші за 3), ```[3]``` (опорний), ```[7, 9, 5, 8]``` (більші за 3). Масив тепер виглядає як ```[2, 1, 3, 7, 9, 5, 8]```.

5. Індекс опорного елемента ```3``` — це ```2```. Позиція (1-based) — ```3```.

6. ```pivot_position``` (```3```) дорівнює ```k``` (```3```), тому ми повертаємо ```arr[2]```, що є ```3```. Це і є 3-й найменший елемент.

У випадку, якщо б ```k``` було ```6```, ```pivot_position``` (```3```) був би меншим за ```k```, і ми б рекурсивно шукали 6-й елемент у правій частині масиву ```[7, 9, 5, 8]```. Цей процес тривав би до знаходження шуканого елемента.

**Переваги Quick Select**
- **Ефективність:** у середньому випадку алгоритм працює за **O(n)**, що значно швидше за сортування масиву (наприклад, Quick Sort або Merge Sort, які мають складність **O(n log n)**).

- **Використання пам'яті:** алгоритм реалізований "на місці" (in-place), тобто не потребує додаткової пам'яті для копіювання масиву.

- **Практичність:** ідеально підходить для задач, де потрібно знайти конкретний елемент, а не повністю сортувати масив, наприклад, для обчислення медіани.